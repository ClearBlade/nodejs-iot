// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **

/* global window */
import type {Callback, CallOptions, PaginationCallback} from 'google-gax';
//import {Transform} from 'stream';
import * as protos from '../../protos/protos';
import * as https from 'https';
import {URL} from 'url';

function requestFactory<
  RequestObject,
  ResponseObject,
  NextRequestObject,
  RawResponseObject
>(
  fetcher: (request: RequestObject) => Promise<RawResponseObject>,
  {
    getResponseObject,
    getNextRequestObject,
  }: {
    getResponseObject: (rawResponseObject: RawResponseObject) => ResponseObject;
    getNextRequestObject: () => NextRequestObject;
  }
) {
  return function makeRequest(
    request: RequestObject,
    options: CallOptions,
    callback?: Callback<ResponseObject, NextRequestObject, RawResponseObject>
  ): Promise<[ResponseObject, NextRequestObject, RawResponseObject]> | void {
    if (callback) {
      fetcher(request)
        .then(data => {
          callback(null, getResponseObject(data), getNextRequestObject(), data);
        })
        .catch(e => {
          callback(new Error(e));
        });
    } else {
      return fetcher(request).then(data => {
        return [getResponseObject(data), getNextRequestObject(), data];
      });
    }
  };
}

export interface ServiceAccountCredentials {
  systemKey: string;
  token: string;
  url: string;
  project: string;
}

interface GetRegistryCredentialsResponse {
  systemKey: string;
  serviceAccountToken: string;
  url: string;
}

function isGetRegistryCredentialsResponse(
  data: unknown
): data is GetRegistryCredentialsResponse {
  return (
    typeof data !== 'undefined' &&
    data !== null &&
    typeof data === 'object' &&
    typeof (data as GetRegistryCredentialsResponse).systemKey === 'string' &&
    typeof (data as GetRegistryCredentialsResponse).serviceAccountToken ===
      'string' &&
    typeof (data as GetRegistryCredentialsResponse).url === 'string'
  );
}

function IoTCoreError(msg: string) {
  return {
    details: msg,
  };
}
IoTCoreError.KNOWN_ERRORS = {
  NO_STATUS_CODE: 'Networking error. No status code was returned',
};

function isErrorStatusCode(statusCode: number): boolean {
  if (statusCode < 200 || statusCode > 299) {
    return true;
  }
  return false;
}

function loadServiceAccountCredentials(
  opts?: DeviceManagerClientOptions
): ServiceAccountCredentials {
  const configFilePath = process.env.CLEARBLADE_CONFIGURATION;
  if (typeof configFilePath === 'undefined' && typeof opts === 'undefined') {
    throw new Error(
      'Must supply service account credentials via constructor or CLEARBLADE_CONFIGURATION environment variable'
    );
  }

  if (typeof opts !== 'undefined' && typeof opts.credentials !== 'undefined') {
    if (!isServiceAccountCredentials(opts.credentials)) {
      throw new Error('Invalid credentials supplied to constructor options');
    } else {
      return opts.credentials;
    }
  }

  if (!configFilePath) {
    throw new Error(
      'No credentials provided via constructor options or CLEARBLADE_CONFIGURATION environment variable'
    );
  }
  let json: unknown;
  try {
    json = require(configFilePath);
  } catch (e) {
    console.error(
      `Failed to load configuration file from ${configFilePath}`,
      e
    );
    throw new Error(`Failed to load configuration file from ${configFilePath}`);
  }
  if (!isServiceAccountCredentials(json)) {
    throw new Error(
      `File loaded from ${configFilePath} is invalid. Please make sure it is a json file with the properties systemKey, token, url, and project`
    );
  } else {
    return json;
  }
}

function isServiceAccountCredentials(
  maybeCredentials: unknown
): maybeCredentials is ServiceAccountCredentials {
  return (
    typeof maybeCredentials === 'object' &&
    maybeCredentials !== null &&
    typeof (maybeCredentials as ServiceAccountCredentials).systemKey ===
      'string' &&
    typeof (maybeCredentials as ServiceAccountCredentials).token === 'string' &&
    typeof (maybeCredentials as ServiceAccountCredentials).url === 'string' &&
    typeof (maybeCredentials as ServiceAccountCredentials).project === 'string'
  );
}

interface DeviceManagerClientOptions {
  credentials?: ServiceAccountCredentials;
}

/**
 *  Internet of Things (IoT) service. Securely connect and manage IoT devices.
 * @class
 * @memberof v1
 */
export class DeviceManagerClient {
  private PROJECT_ID: string;
  private BASE_URL: string;
  private ADMIN_SYSTEM_KEY: string;
  private ADMIN_USER_TOKEN: string;
  // descriptors: Descriptors = {
  //   page: {},
  //   stream: {},
  //   longrunning: {},
  //   batching: {},
  // };
  // warn: (code: string, message: string, warnType?: string) => void;
  innerApiCalls: {[name: string]: Function};
  //pathTemplates: {[name: string]: gax.PathTemplate};
  // deviceManagerStub?: Promise<{[name: string]: Function}>;

  constructor(opts?: DeviceManagerClientOptions) {
    const serviceAccountCredentials = loadServiceAccountCredentials(opts);
    this.ADMIN_SYSTEM_KEY = serviceAccountCredentials.systemKey;
    this.ADMIN_USER_TOKEN = serviceAccountCredentials.token;
    this.PROJECT_ID = serviceAccountCredentials.project;
    this.BASE_URL = serviceAccountCredentials.url.replace(/^https?:\/\//, '');

    this.innerApiCalls = {
      createDeviceRegistry: this._createDeviceRegistry,
    };
  }

  /**
   * Initialize the client.
   * Performs asynchronous operations (such as authentication) and prepares the client.
   * This function will be called automatically when any class method is called for the
   * first time, but if you need to initialize it before calling an actual method,
   * feel free to call initialize() directly.
   *
   * You can await on this method if you want to make sure the client is initialized.
   *
   * @returns {Promise} A promise that resolves to an authenticated service stub.
   */
  initialize() {
    //   // If the client stub promise is already initialized, return immediately.
    //   if (this.deviceManagerStub) {
    //     return this.deviceManagerStub;
    //   }
    //   // Put together the "service stub" for
    //   // google.cloud.iot.v1.DeviceManager.
    //   this.deviceManagerStub = this._gaxGrpc.createStub(
    //     this._opts.fallback
    //       ? (this._protos as protobuf.Root).lookupService(
    //           'google.cloud.iot.v1.DeviceManager'
    //         )
    //       : // eslint-disable-next-line @typescript-eslint/no-explicit-any
    //         (this._protos as any).google.cloud.iot.v1.DeviceManager,
    //     this._opts,
    //     this._providedCustomServicePath
    //   ) as Promise<{[method: string]: Function}>;
    //   // Iterate over each of the methods that the service provides
    //   // and create an API call method for each.
    //   const deviceManagerStubMethods = [
    //     'createDeviceRegistry',
    //     'getDeviceRegistry',
    //     'updateDeviceRegistry',
    //     'deleteDeviceRegistry',
    //     'listDeviceRegistries',
    //     'createDevice',
    //     'getDevice',
    //     'updateDevice',
    //     'deleteDevice',
    //     'listDevices',
    //     'modifyCloudToDeviceConfig',
    //     'listDeviceConfigVersions',
    //     'listDeviceStates',
    //     'setIamPolicy',
    //     'getIamPolicy',
    //     'testIamPermissions',
    //     'sendCommandToDevice',
    //     'bindDeviceToGateway',
    //     'unbindDeviceFromGateway',
    //   ];
    //   for (const methodName of deviceManagerStubMethods) {
    //     const callPromise = this.deviceManagerStub.then(
    //       stub =>
    //         (...args: Array<{}>) => {
    //           if (this._terminated) {
    //             return Promise.reject('The client has already been closed.');
    //           }
    //           const func = stub[methodName];
    //           return func.apply(stub, args);
    //         },
    //       (err: Error | null | undefined) => () => {
    //         throw err;
    //       }
    //     );
    //     const descriptor = this.descriptors.page[methodName] || undefined;
    //     const apiCall = this._gaxModule.createApiCall(
    //       callPromise,
    //       this._defaults[methodName],
    //       descriptor,
    //       this._opts.fallback
    //     );
    //     this.innerApiCalls[methodName] = apiCall;
    //   }
    //   return this.deviceManagerStub;
  }

  /**
   * The DNS address for this API service.
   * @returns {string} The DNS address for this service.
   */
  static get servicePath() {
    return 'cloudiot.googleapis.com';
  }

  /**
   * The DNS address for this API service - same as servicePath(),
   * exists for compatibility reasons.
   * @returns {string} The DNS address for this service.
   */
  static get apiEndpoint() {
    return 'cloudiot.googleapis.com';
  }

  /**
   * The port for this API service.
   * @returns {number} The default port for this service.
   */
  static get port() {
    return 443;
  }

  /**
   * The scopes needed to make gRPC calls for every method defined
   * in this service.
   * @returns {string[]} List of default scopes.
   */
  static get scopes() {
    return [
      'https://www.googleapis.com/auth/cloud-platform',
      'https://www.googleapis.com/auth/cloudiot',
    ];
  }

  getProjectId(): Promise<string>;
  getProjectId(callback: Callback<string, undefined, undefined>): void;
  /**
   * Return the project ID used by this class.
   * @returns {Promise} A promise that resolves to string containing the project ID.
   */
  getProjectId(
    callback?: Callback<string, undefined, undefined>
  ): Promise<string> | void {
    if (typeof callback !== 'undefined') {
      callback(null, this.PROJECT_ID);
    } else {
      return Promise.resolve('' + this.PROJECT_ID);
    }
  }

  // -------------------
  // -- Service calls --
  // -------------------
  /**
   * Creates a device registry that contains devices.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The project and cloud region where this device registry must be created.
   *   For example, `projects/example-project/locations/us-central1`.
   * @param {google.cloud.iot.v1.DeviceRegistry} request.deviceRegistry
   *   Required. The device registry. The field `name` must be empty. The server will
   *   generate that field from the device registry `id` provided and the
   *   `parent` field.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [DeviceRegistry]{@link google.cloud.iot.v1.DeviceRegistry}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example <caption>include:samples/generated/v1/device_manager.create_device_registry.js</caption>
   * region_tag:cloudiot_v1_generated_DeviceManager_CreateDeviceRegistry_async
   */
  createDeviceRegistry(
    request?: protos.google.cloud.iot.v1.ICreateDeviceRegistryRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.iot.v1.IDeviceRegistry,
      protos.google.cloud.iot.v1.ICreateDeviceRegistryRequest | undefined,
      {} | undefined
    ]
  >;
  createDeviceRegistry(
    request: protos.google.cloud.iot.v1.ICreateDeviceRegistryRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.cloud.iot.v1.IDeviceRegistry,
      | protos.google.cloud.iot.v1.ICreateDeviceRegistryRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  createDeviceRegistry(
    request: protos.google.cloud.iot.v1.ICreateDeviceRegistryRequest,
    callback: Callback<
      protos.google.cloud.iot.v1.IDeviceRegistry,
      | protos.google.cloud.iot.v1.ICreateDeviceRegistryRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  createDeviceRegistry(
    request?: protos.google.cloud.iot.v1.ICreateDeviceRegistryRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.cloud.iot.v1.IDeviceRegistry,
          | protos.google.cloud.iot.v1.ICreateDeviceRegistryRequest
          | null
          | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.cloud.iot.v1.IDeviceRegistry,
      | protos.google.cloud.iot.v1.ICreateDeviceRegistryRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.cloud.iot.v1.IDeviceRegistry,
      protos.google.cloud.iot.v1.ICreateDeviceRegistryRequest | undefined,
      {} | undefined
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};

    return this.innerApiCalls.createDeviceRegistry(request, options, callback);
  }

  private _createDeviceRegistry = requestFactory<
    protos.google.cloud.iot.v1.ICreateDeviceRegistryRequest,
    protos.google.cloud.iot.v1.IDeviceRegistry,
    protos.google.cloud.iot.v1.ICreateDeviceRegistryRequest | undefined,
    protos.google.cloud.iot.v1.IDeviceRegistry
  >(
    request => {
      return new Promise((resolve, reject) => {
        const payload = JSON.stringify(request?.deviceRegistry);
        const options = {
          host: this.BASE_URL,
          path: `/api/v/4/webhook/execute/${this.ADMIN_SYSTEM_KEY}/cloudiot?parent=${request?.parent}`,
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'ClearBlade-UserToken': this.ADMIN_USER_TOKEN,
            'Content-Length': payload.length,
          },
        };

        const req = https.request(
          {
            ...options,
          },
          res => {
            if (typeof res.statusCode === 'undefined') {
              reject(IoTCoreError(IoTCoreError.KNOWN_ERRORS.NO_STATUS_CODE));
            } else if (isErrorStatusCode(res.statusCode)) {
              let errorData = '';
              res.on('data', chunk => (errorData += chunk));
              res.on('end', () => {
                reject(IoTCoreError(errorData));
              });
            } else {
              let data = '';
              res.on('data', chunk => (data += chunk));
              res.on('end', () => {
                const deviceRegistry: protos.google.cloud.iot.v1.IDeviceRegistry =
                  JSON.parse(data);
                resolve(deviceRegistry);
              });
            }
          }
        );
        req.on('error', e => {
          reject(e);
        });
        if (payload) {
          req.write(payload);
        }
        req.end();
      });
    },
    {
      getResponseObject: response => response,
      getNextRequestObject: () => undefined,
    }
  );
  /**
   * Gets a device registry configuration.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.name
   *   Required. The name of the device registry. For example,
   *   `projects/example-project/locations/us-central1/registries/my-registry`.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [DeviceRegistry]{@link google.cloud.iot.v1.DeviceRegistry}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example <caption>include:samples/generated/v1/device_manager.get_device_registry.js</caption>
   * region_tag:cloudiot_v1_generated_DeviceManager_GetDeviceRegistry_async
   */
  getDeviceRegistry(
    request?: protos.google.cloud.iot.v1.IGetDeviceRegistryRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.iot.v1.IDeviceRegistry,
      protos.google.cloud.iot.v1.IGetDeviceRegistryRequest | undefined,
      {} | undefined
    ]
  >;
  getDeviceRegistry(
    request: protos.google.cloud.iot.v1.IGetDeviceRegistryRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.cloud.iot.v1.IDeviceRegistry,
      protos.google.cloud.iot.v1.IGetDeviceRegistryRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  getDeviceRegistry(
    request: protos.google.cloud.iot.v1.IGetDeviceRegistryRequest,
    callback: Callback<
      protos.google.cloud.iot.v1.IDeviceRegistry,
      protos.google.cloud.iot.v1.IGetDeviceRegistryRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  getDeviceRegistry(
    request?: protos.google.cloud.iot.v1.IGetDeviceRegistryRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.cloud.iot.v1.IDeviceRegistry,
          | protos.google.cloud.iot.v1.IGetDeviceRegistryRequest
          | null
          | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.cloud.iot.v1.IDeviceRegistry,
      protos.google.cloud.iot.v1.IGetDeviceRegistryRequest | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.cloud.iot.v1.IDeviceRegistry,
      protos.google.cloud.iot.v1.IGetDeviceRegistryRequest | undefined,
      {} | undefined
    ]
  > | void {
    // request = request || {};
    // let options: CallOptions;
    // if (typeof optionsOrCallback === 'function' && callback === undefined) {
    //   callback = optionsOrCallback;
    //   options = {};
    // } else {
    //   options = optionsOrCallback as CallOptions;
    // }
    // options = options || {};
    // options.otherArgs = options.otherArgs || {};
    // options.otherArgs.headers = options.otherArgs.headers || {};
    // options.otherArgs.headers['x-goog-request-params'] =
    //   this._gaxModule.routingHeader.fromParams({
    //     name: request.name || '',
    //   });
    // this.initialize();
    // return this.innerApiCalls.getDeviceRegistry(request, options, callback);
    return undefined;
  }
  /**
   * Updates a device registry configuration.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {google.cloud.iot.v1.DeviceRegistry} request.deviceRegistry
   *   Required. The new values for the device registry. The `id` field must be empty, and
   *   the `name` field must indicate the path of the resource. For example,
   *   `projects/example-project/locations/us-central1/registries/my-registry`.
   * @param {google.protobuf.FieldMask} request.updateMask
   *   Required. Only updates the `device_registry` fields indicated by this mask.
   *   The field mask must not be empty, and it must not contain fields that
   *   are immutable or only set by the server.
   *   Mutable top-level fields: `event_notification_config`, `http_config`,
   *   `mqtt_config`, and `state_notification_config`.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [DeviceRegistry]{@link google.cloud.iot.v1.DeviceRegistry}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example <caption>include:samples/generated/v1/device_manager.update_device_registry.js</caption>
   * region_tag:cloudiot_v1_generated_DeviceManager_UpdateDeviceRegistry_async
   */
  updateDeviceRegistry(
    request?: protos.google.cloud.iot.v1.IUpdateDeviceRegistryRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.iot.v1.IDeviceRegistry,
      protos.google.cloud.iot.v1.IUpdateDeviceRegistryRequest | undefined,
      {} | undefined
    ]
  >;
  updateDeviceRegistry(
    request: protos.google.cloud.iot.v1.IUpdateDeviceRegistryRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.cloud.iot.v1.IDeviceRegistry,
      | protos.google.cloud.iot.v1.IUpdateDeviceRegistryRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  updateDeviceRegistry(
    request: protos.google.cloud.iot.v1.IUpdateDeviceRegistryRequest,
    callback: Callback<
      protos.google.cloud.iot.v1.IDeviceRegistry,
      | protos.google.cloud.iot.v1.IUpdateDeviceRegistryRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  updateDeviceRegistry(
    request?: protos.google.cloud.iot.v1.IUpdateDeviceRegistryRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.cloud.iot.v1.IDeviceRegistry,
          | protos.google.cloud.iot.v1.IUpdateDeviceRegistryRequest
          | null
          | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.cloud.iot.v1.IDeviceRegistry,
      | protos.google.cloud.iot.v1.IUpdateDeviceRegistryRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.cloud.iot.v1.IDeviceRegistry,
      protos.google.cloud.iot.v1.IUpdateDeviceRegistryRequest | undefined,
      {} | undefined
    ]
  > | void {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      const registry = this.getRegistryFromRegistryPath(
        request?.deviceRegistry?.name
      );
      const region = this.getRegionFromRegistryPath(
        request?.deviceRegistry?.name
      );
      const token_response = await this.getRegistryToken(registry, region);
      const payload = JSON.stringify(request?.deviceRegistry);

      const options = {
        host: token_response.host,
        path:
          '/api/v/4/webhook/execute/' +
          token_response.systemKey +
          '/cloudiot?name=' +
          request?.deviceRegistry?.name +
          '&updateMask=' +
          request?.updateMask,
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'ClearBlade-UserToken': token_response.serviceAccountToken,
          'Content-Length': payload.length,
        },
      };

      const req = https.request(
        {
          ...options,
        },
        res => {
          if (typeof res.statusCode === 'undefined') {
            reject(IoTCoreError(IoTCoreError.KNOWN_ERRORS.NO_STATUS_CODE));
          } else if (isErrorStatusCode(res.statusCode)) {
            let errorData = '';
            res.on('data', chunk => (errorData += chunk));
            res.on('end', () => {
              reject(IoTCoreError(errorData));
            });
          } else {
            let data = '';
            res.on('data', chunk => (data += chunk));
            res.on('end', () => {
              const deviceRegistry: protos.google.cloud.iot.v1.IDeviceRegistry =
                JSON.parse(data);
              resolve([deviceRegistry, {}, {}]);
            });
          }
        }
      );
      req.on('error', e => {
        reject(e);
      });
      if (payload) {
        req.write(payload);
      }
      req.end();
    });
  }
  /**
   * Deletes a device registry configuration.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.name
   *   Required. The name of the device registry. For example,
   *   `projects/example-project/locations/us-central1/registries/my-registry`.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [Empty]{@link google.protobuf.Empty}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example <caption>include:samples/generated/v1/device_manager.delete_device_registry.js</caption>
   * region_tag:cloudiot_v1_generated_DeviceManager_DeleteDeviceRegistry_async
   */
  deleteDeviceRegistry(
    request?: protos.google.cloud.iot.v1.IDeleteDeviceRegistryRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.protobuf.IEmpty,
      protos.google.cloud.iot.v1.IDeleteDeviceRegistryRequest | undefined,
      {} | undefined
    ]
  >;
  deleteDeviceRegistry(
    request: protos.google.cloud.iot.v1.IDeleteDeviceRegistryRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.protobuf.IEmpty,
      | protos.google.cloud.iot.v1.IDeleteDeviceRegistryRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  deleteDeviceRegistry(
    request: protos.google.cloud.iot.v1.IDeleteDeviceRegistryRequest,
    callback: Callback<
      protos.google.protobuf.IEmpty,
      | protos.google.cloud.iot.v1.IDeleteDeviceRegistryRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  deleteDeviceRegistry(
    request?: protos.google.cloud.iot.v1.IDeleteDeviceRegistryRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.protobuf.IEmpty,
          | protos.google.cloud.iot.v1.IDeleteDeviceRegistryRequest
          | null
          | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.protobuf.IEmpty,
      | protos.google.cloud.iot.v1.IDeleteDeviceRegistryRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.protobuf.IEmpty,
      protos.google.cloud.iot.v1.IDeleteDeviceRegistryRequest | undefined,
      {} | undefined
    ]
  > | void {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      const payload = JSON.stringify({
        name: request?.name,
      });
      const options = {
        host: this.BASE_URL,
        path:
          '/api/v/4/webhook/execute/' +
          this.ADMIN_SYSTEM_KEY +
          '/cloudiot?name=' +
          request?.name,
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          'ClearBlade-UserToken': this.ADMIN_USER_TOKEN,
        },
      };

      const req = https.request(
        {
          ...options,
        },
        res => {
          if (typeof res.statusCode === 'undefined') {
            reject(IoTCoreError(IoTCoreError.KNOWN_ERRORS.NO_STATUS_CODE));
          } else if (isErrorStatusCode(res.statusCode)) {
            let errorData = '';
            res.on('data', chunk => (errorData += chunk));
            res.on('end', () => {
              reject(IoTCoreError(errorData));
            });
          } else {
            let data = '';
            const chunks: any[] = [];
            res.on('data', chunk => (data += chunk));
            res.on('end', () => {
              let array: [
                protos.google.protobuf.IEmpty,
                (
                  | protos.google.cloud.iot.v1.IDeleteDeviceRegistryRequest
                  | undefined
                ),
                {} | undefined
              ];

              const IDeleteDeviceRegistryRequest:
                | protos.google.cloud.iot.v1.IDeleteDeviceRegistryRequest
                | undefined = {};
              const iempty: protos.google.protobuf.IEmpty = {};
              // eslint-disable-next-line prefer-const
              array = [IDeleteDeviceRegistryRequest, iempty, {}];
              resolve(array);
            });
          }
        }
      );
      req.on('error', e => {
        reject(e);
      });
      if (payload) {
        req.write(payload);
      }
      req.end();
    });
  }
  /**
   * Creates a device in a device registry.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The name of the device registry where this device should be created.
   *   For example,
   *   `projects/example-project/locations/us-central1/registries/my-registry`.
   * @param {google.cloud.iot.v1.Device} request.device
   *   Required. The device registration details. The field `name` must be empty. The server
   *   generates `name` from the device registry `id` and the
   *   `parent` field.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [Device]{@link google.cloud.iot.v1.Device}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example <caption>include:samples/generated/v1/device_manager.create_device.js</caption>
   * region_tag:cloudiot_v1_generated_DeviceManager_CreateDevice_async
   */
  createDevice(
    request?: protos.google.cloud.iot.v1.ICreateDeviceRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.iot.v1.IDevice,
      protos.google.cloud.iot.v1.ICreateDeviceRequest | undefined,
      {} | undefined
    ]
  >;
  createDevice(
    request: protos.google.cloud.iot.v1.ICreateDeviceRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.cloud.iot.v1.IDevice,
      protos.google.cloud.iot.v1.ICreateDeviceRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  createDevice(
    request: protos.google.cloud.iot.v1.ICreateDeviceRequest,
    callback: Callback<
      protos.google.cloud.iot.v1.IDevice,
      protos.google.cloud.iot.v1.ICreateDeviceRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  createDevice(
    request?: protos.google.cloud.iot.v1.ICreateDeviceRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.cloud.iot.v1.IDevice,
          protos.google.cloud.iot.v1.ICreateDeviceRequest | null | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.cloud.iot.v1.IDevice,
      protos.google.cloud.iot.v1.ICreateDeviceRequest | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.cloud.iot.v1.IDevice,
      protos.google.cloud.iot.v1.ICreateDeviceRequest | undefined,
      {} | undefined
    ]
  > | void {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      const registry = this.getRegistryFromRegistryPath(request?.parent);
      const region = this.getRegionFromRegistryPath(request?.parent);
      const token_response = await this.getRegistryToken(registry, region);
      const payload = JSON.stringify(request?.device);
      const options = {
        host: token_response.host,
        path:
          '/api/v/4/webhook/execute/' +
          token_response.systemKey +
          '/cloudiot_devices',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'ClearBlade-UserToken': token_response.serviceAccountToken,
          'Content-Length': payload.length,
        },
      };
      const req = https.request(
        {
          ...options,
        },
        res => {
          if (typeof res.statusCode === 'undefined') {
            reject(IoTCoreError(IoTCoreError.KNOWN_ERRORS.NO_STATUS_CODE));
          } else if (isErrorStatusCode(res.statusCode)) {
            let errorData = '';
            res.on('data', chunk => (errorData += chunk));
            res.on('end', () => {
              reject(IoTCoreError(errorData));
            });
          } else {
            let data = '';
            res.on('data', chunk => (data += chunk));
            res.on('end', () => {
              if (!this.isJsonString(data)) {
                reject(data);
                return;
              }
              let array: [
                protos.google.cloud.iot.v1.IDevice,
                protos.google.cloud.iot.v1.ICreateDeviceRequest | undefined,
                {} | undefined
              ];
              const deviceResponse = JSON.parse(data);
              const icreatedevicerequest:
                | protos.google.cloud.iot.v1.ICreateDeviceRequest
                | undefined = {};
              const device: protos.google.cloud.iot.v1.IDevice = {};
              device.id = deviceResponse.id;
              device.name = deviceResponse.name;
              device.numId = deviceResponse.numId;
              device.credentials = deviceResponse.credentials;
              device.lastHeartbeatTime = deviceResponse.lastHeartbeatTime;
              device.lastEventTime = deviceResponse.lastEventTime;
              device.lastStateTime = deviceResponse.lastStateTime;
              device.lastConfigAckTime = deviceResponse.lastConfigAckTime;
              device.lastConfigSendTime = deviceResponse.lastConfigSendTime;
              device.blocked = deviceResponse.blocked;
              device.lastErrorTime = deviceResponse.lastErrorTime;
              device.lastErrorStatus = deviceResponse.lastErrorStatus;
              device.config = deviceResponse.config;
              device.state = deviceResponse.state;
              device.logLevel = deviceResponse.logLevel;
              device.metadata = deviceResponse.metadata;
              device.gatewayConfig = deviceResponse.gatewayConfig;

              // eslint-disable-next-line prefer-const
              array = [device, icreatedevicerequest, {}];
              resolve(array);
            });
          }
        }
      );
      req.on('error', e => {
        console.log('error: ', e);
        reject(e);
      });
      if (payload) {
        req.write(payload);
      }
      req.end();
    });
  }
  /**
   * Gets details about a device.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.name
   *   Required. The name of the device. For example,
   *   `projects/p0/locations/us-central1/registries/registry0/devices/device0` or
   *   `projects/p0/locations/us-central1/registries/registry0/devices/{num_id}`.
   * @param {google.protobuf.FieldMask} request.fieldMask
   *   The fields of the `Device` resource to be returned in the response. If the
   *   field mask is unset or empty, all fields are returned. Fields have to be
   *   provided in snake_case format, for example: `last_heartbeat_time`.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [Device]{@link google.cloud.iot.v1.Device}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example <caption>include:samples/generated/v1/device_manager.get_device.js</caption>
   * region_tag:cloudiot_v1_generated_DeviceManager_GetDevice
   */
  getDevice(
    request?: protos.google.cloud.iot.v1.IGetDeviceRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.iot.v1.IDevice,
      protos.google.cloud.iot.v1.IGetDeviceRequest | undefined,
      {} | undefined
    ]
  >;
  getDevice(
    request: protos.google.cloud.iot.v1.IGetDeviceRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.cloud.iot.v1.IDevice,
      protos.google.cloud.iot.v1.IGetDeviceRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  getDevice(
    request: protos.google.cloud.iot.v1.IGetDeviceRequest,
    callback: Callback<
      protos.google.cloud.iot.v1.IDevice,
      protos.google.cloud.iot.v1.IGetDeviceRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  getDevice(
    request?: protos.google.cloud.iot.v1.IGetDeviceRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.cloud.iot.v1.IDevice,
          protos.google.cloud.iot.v1.IGetDeviceRequest | null | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.cloud.iot.v1.IDevice,
      protos.google.cloud.iot.v1.IGetDeviceRequest | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.cloud.iot.v1.IDevice,
      protos.google.cloud.iot.v1.IGetDeviceRequest | undefined,
      {} | undefined
    ]
  > | void {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      const registry = this.getRegistryFromDevicePath(request?.name);
      const region = this.getRegionFromDevicePath(request?.name);
      const token_response = await this.getRegistryToken(registry, region);

      const options = {
        host: token_response.host,
        path:
          '/api/v/4/webhook/execute/' +
          token_response.systemKey +
          '/cloudiot_devices?name=' +
          request?.name,
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'ClearBlade-UserToken': token_response.serviceAccountToken,
        },
      };

      const req = https.request(
        {
          ...options,
        },
        res => {
          if (typeof res.statusCode === 'undefined') {
            reject(IoTCoreError(IoTCoreError.KNOWN_ERRORS.NO_STATUS_CODE));
          } else if (isErrorStatusCode(res.statusCode)) {
            let errorData = '';
            res.on('data', chunk => (errorData += chunk));
            res.on('end', () => {
              reject(IoTCoreError(errorData));
            });
          } else {
            let data = '';
            res.on('data', chunk => (data += chunk));
            res.on('end', () => {
              const device: protos.google.cloud.iot.v1.IDevice =
                JSON.parse(data);
              resolve([device, {}, {}]);
            });
          }
        }
      );
      req.on('error', e => {
        reject(e);
      });

      req.end();
    });
  }
  /**
   * Updates a device.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {google.cloud.iot.v1.Device} request.device
   *   Required. The new values for the device. The `id` and `num_id` fields must
   *   be empty, and the field `name` must specify the name path. For example,
   *   `projects/p0/locations/us-central1/registries/registry0/devices/device0`or
   *   `projects/p0/locations/us-central1/registries/registry0/devices/{num_id}`.
   * @param {google.protobuf.FieldMask} request.updateMask
   *   Required. Only updates the `device` fields indicated by this mask.
   *   The field mask must not be empty, and it must not contain fields that
   *   are immutable or only set by the server.
   *   Mutable top-level fields: `credentials`, `blocked`, and `metadata`
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [Device]{@link google.cloud.iot.v1.Device}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example <caption>include:samples/generated/v1/device_manager.update_device.js</caption>
   * region_tag:cloudiot_v1_generated_DeviceManager_UpdateDevice_async
   */
  updateDevice(
    request?: protos.google.cloud.iot.v1.IUpdateDeviceRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.iot.v1.IDevice,
      protos.google.cloud.iot.v1.IUpdateDeviceRequest | undefined,
      {} | undefined
    ]
  >;
  updateDevice(
    request: protos.google.cloud.iot.v1.IUpdateDeviceRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.cloud.iot.v1.IDevice,
      protos.google.cloud.iot.v1.IUpdateDeviceRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  updateDevice(
    request: protos.google.cloud.iot.v1.IUpdateDeviceRequest,
    callback: Callback<
      protos.google.cloud.iot.v1.IDevice,
      protos.google.cloud.iot.v1.IUpdateDeviceRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  updateDevice(
    request?: protos.google.cloud.iot.v1.IUpdateDeviceRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.cloud.iot.v1.IDevice,
          protos.google.cloud.iot.v1.IUpdateDeviceRequest | null | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.cloud.iot.v1.IDevice,
      protos.google.cloud.iot.v1.IUpdateDeviceRequest | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.cloud.iot.v1.IDevice,
      protos.google.cloud.iot.v1.IUpdateDeviceRequest | undefined,
      {} | undefined
    ]
  > | void {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      const registry = this.getRegistryFromDevicePath(request?.device?.name);
      const region = this.getRegionFromDevicePath(request?.device?.name);
      const deviceName = this.getDeviceNameFromDevicePath(
        request?.device?.name
      );
      const token_response = await this.getRegistryToken(registry, region);
      const payload = JSON.stringify(request?.device);

      const options = {
        host: token_response.host,
        path:
          '/api/v/4/webhook/execute/' +
          token_response.systemKey +
          '/cloudiot_devices?name=' +
          deviceName +
          '&updateMask=' +
          request?.updateMask,
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'ClearBlade-UserToken': token_response.serviceAccountToken,
          'Content-Length': payload.length,
        },
      };

      const req = https.request(
        {
          ...options,
        },
        res => {
          if (typeof res.statusCode === 'undefined') {
            reject(IoTCoreError(IoTCoreError.KNOWN_ERRORS.NO_STATUS_CODE));
          } else if (isErrorStatusCode(res.statusCode)) {
            let errorData = '';
            res.on('data', chunk => (errorData += chunk));
            res.on('end', () => {
              reject(IoTCoreError(errorData));
            });
          } else {
            let data = '';
            res.on('data', chunk => (data += chunk));
            res.on('end', () => {
              const device: protos.google.cloud.iot.v1.IDevice =
                JSON.parse(data);
              resolve([device, {}, {}]);
            });
          }
        }
      );
      req.on('error', e => {
        reject(e);
      });
      if (payload) {
        req.write(payload);
      }
      req.end();
    });
  }
  /**
   * Deletes a device.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.name
   *   Required. The name of the device. For example,
   *   `projects/p0/locations/us-central1/registries/registry0/devices/device0` or
   *   `projects/p0/locations/us-central1/registries/registry0/devices/{num_id}`.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [Empty]{@link google.protobuf.Empty}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example <caption>include:samples/generated/v1/device_manager.delete_device.js</caption>
   * region_tag:cloudiot_v1_generated_DeviceManager_DeleteDevice_async
   */
  deleteDevice(
    request?: protos.google.cloud.iot.v1.IDeleteDeviceRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.protobuf.IEmpty,
      protos.google.cloud.iot.v1.IDeleteDeviceRequest | undefined,
      {} | undefined
    ]
  >;
  deleteDevice(
    request: protos.google.cloud.iot.v1.IDeleteDeviceRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.protobuf.IEmpty,
      protos.google.cloud.iot.v1.IDeleteDeviceRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  deleteDevice(
    request: protos.google.cloud.iot.v1.IDeleteDeviceRequest,
    callback: Callback<
      protos.google.protobuf.IEmpty,
      protos.google.cloud.iot.v1.IDeleteDeviceRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  deleteDevice(
    request?: protos.google.cloud.iot.v1.IDeleteDeviceRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.protobuf.IEmpty,
          protos.google.cloud.iot.v1.IDeleteDeviceRequest | null | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.protobuf.IEmpty,
      protos.google.cloud.iot.v1.IDeleteDeviceRequest | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.protobuf.IEmpty,
      protos.google.cloud.iot.v1.IDeleteDeviceRequest | undefined,
      {} | undefined
    ]
  > | void {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      const registry = this.getRegistryFromDevicePath(request?.name);
      const region = this.getRegionFromDevicePath(request?.name);
      const deviceName = this.getDeviceNameFromDevicePath(request?.name);
      const token_response = await this.getRegistryToken(registry, region);

      const options = {
        host: token_response.host,
        path:
          '/api/v/4/webhook/execute/' +
          token_response.systemKey +
          '/cloudiot_devices?name=' +
          request?.name,
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          'ClearBlade-UserToken': token_response.serviceAccountToken,
        },
      };

      const req = https.request(
        {
          ...options,
        },
        res => {
          if (typeof res.statusCode === 'undefined') {
            reject(IoTCoreError(IoTCoreError.KNOWN_ERRORS.NO_STATUS_CODE));
          } else if (isErrorStatusCode(res.statusCode)) {
            let errorData = '';
            res.on('data', chunk => (errorData += chunk));
            res.on('end', () => {
              reject(IoTCoreError(errorData));
            });
          } else {
            let data = '';
            const chunks: any[] = [];
            res.on('data', chunk => (data += chunk));
            res.on('end', () => {
              let array: [
                protos.google.protobuf.IEmpty,
                protos.google.cloud.iot.v1.IDeleteDeviceRequest | undefined,
                {} | undefined
              ];

              const ideletedevicerequest:
                | protos.google.cloud.iot.v1.IDeleteDeviceRequest
                | undefined = {};
              const iempty: protos.google.protobuf.IEmpty = {};
              // eslint-disable-next-line prefer-const
              array = [ideletedevicerequest, iempty, {}];
              resolve(array);
            });
          }
        }
      );
      req.on('error', e => {
        reject(e);
      });
      req.end();
    });
  }
  /**
   * Modifies the configuration for the device, which is eventually sent from
   * the Cloud IoT Core servers. Returns the modified configuration version and
   * its metadata.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.name
   *   Required. The name of the device. For example,
   *   `projects/p0/locations/us-central1/registries/registry0/devices/device0` or
   *   `projects/p0/locations/us-central1/registries/registry0/devices/{num_id}`.
   * @param {number} request.versionToUpdate
   *   The version number to update. If this value is zero, it will not check the
   *   version number of the server and will always update the current version;
   *   otherwise, this update will fail if the version number found on the server
   *   does not match this version number. This is used to support multiple
   *   simultaneous updates without losing data.
   * @param {Buffer} request.binaryData
   *   Required. The configuration data for the device.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [DeviceConfig]{@link google.cloud.iot.v1.DeviceConfig}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example <caption>include:samples/generated/v1/device_manager.modify_cloud_to_device_config.js</caption>
   * region_tag:cloudiot_v1_generated_DeviceManager_ModifyCloudToDeviceConfig_async
   */
  modifyCloudToDeviceConfig(
    request?: protos.google.cloud.iot.v1.IModifyCloudToDeviceConfigRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.iot.v1.IDeviceConfig,
      protos.google.cloud.iot.v1.IModifyCloudToDeviceConfigRequest | undefined,
      {} | undefined
    ]
  >;
  modifyCloudToDeviceConfig(
    request: protos.google.cloud.iot.v1.IModifyCloudToDeviceConfigRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.cloud.iot.v1.IDeviceConfig,
      | protos.google.cloud.iot.v1.IModifyCloudToDeviceConfigRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  modifyCloudToDeviceConfig(
    request: protos.google.cloud.iot.v1.IModifyCloudToDeviceConfigRequest,
    callback: Callback<
      protos.google.cloud.iot.v1.IDeviceConfig,
      | protos.google.cloud.iot.v1.IModifyCloudToDeviceConfigRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  modifyCloudToDeviceConfig(
    request?: protos.google.cloud.iot.v1.IModifyCloudToDeviceConfigRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.cloud.iot.v1.IDeviceConfig,
          | protos.google.cloud.iot.v1.IModifyCloudToDeviceConfigRequest
          | null
          | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.cloud.iot.v1.IDeviceConfig,
      | protos.google.cloud.iot.v1.IModifyCloudToDeviceConfigRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.cloud.iot.v1.IDeviceConfig,
      protos.google.cloud.iot.v1.IModifyCloudToDeviceConfigRequest | undefined,
      {} | undefined
    ]
  > | void {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      const registry = this.getRegistryFromDevicePath(request?.name);
      const region = this.getRegionFromDevicePath(request?.name);
      const deviceName = this.getDeviceNameFromDevicePath(request?.name);
      const token_response = await this.getRegistryToken(registry, region);

      const payload = JSON.stringify({
        binaryData: request?.binaryData,
        versionToUpdate: request?.versionToUpdate,
      });
      const options = {
        host: token_response.host,
        path: `/api/v/4/webhook/execute/${token_response.systemKey}/cloudiot_devices?name=${deviceName}&method=modifyCloudToDeviceConfig`,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'ClearBlade-UserToken': token_response.serviceAccountToken,
          'Content-Length': payload.length,
        },
      };

      const req = https.request(
        {
          ...options,
        },
        res => {
          if (typeof res.statusCode === 'undefined') {
            reject(IoTCoreError(IoTCoreError.KNOWN_ERRORS.NO_STATUS_CODE));
          } else if (isErrorStatusCode(res.statusCode)) {
            let errorData = '';
            res.on('data', chunk => (errorData += chunk));
            res.on('end', () => {
              reject(IoTCoreError(errorData));
            });
          } else {
            let data = '';
            res.on('data', chunk => (data += chunk));
            res.on('end', () => {
              if (!this.isJsonString(data)) {
                reject(data);
                return;
              }
              let array: [
                protos.google.cloud.iot.v1.IDeviceConfig,
                (
                  | protos.google.cloud.iot.v1.IModifyCloudToDeviceConfigRequest
                  | undefined
                ),
                {} | undefined
              ];
              const deviceConfig = JSON.parse(data);
              const imodifycloudtodeviceconfigrequest:
                | protos.google.cloud.iot.v1.IModifyCloudToDeviceConfigRequest
                | undefined = {};
              const ideviceconfig: protos.google.cloud.iot.v1.IDeviceConfig =
                {};
              ideviceconfig.binaryData = deviceConfig.binaryData;
              ideviceconfig.version = deviceConfig.version;
              ideviceconfig.cloudUpdateTime = deviceConfig.cloudUpdateTime;
              ideviceconfig.deviceAckTime = deviceConfig.deviceAckTime;
              // eslint-disable-next-line prefer-const
              array = [ideviceconfig, imodifycloudtodeviceconfigrequest, {}];
              resolve(array);
            });
          }
        }
      );
      req.on('error', e => {
        console.log('error: ', e);
        reject(e);
      });
      if (payload) {
        req.write(payload);
      }
      req.end();
    });
  }

  isJsonString(str: string) {
    try {
      JSON.parse(str);
    } catch (e) {
      return false;
    }
    return true;
  }
  /**
   * Lists the last few versions of the device configuration in descending
   * order (i.e.: newest first).
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.name
   *   Required. The name of the device. For example,
   *   `projects/p0/locations/us-central1/registries/registry0/devices/device0` or
   *   `projects/p0/locations/us-central1/registries/registry0/devices/{num_id}`.
   * @param {number} request.numVersions
   *   The number of versions to list. Versions are listed in decreasing order of
   *   the version number. The maximum number of versions retained is 10. If this
   *   value is zero, it will return all the versions available.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [ListDeviceConfigVersionsResponse]{@link google.cloud.iot.v1.ListDeviceConfigVersionsResponse}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example <caption>include:samples/generated/v1/device_manager.list_device_config_versions.js</caption>
   * region_tag:cloudiot_v1_generated_DeviceManager_ListDeviceConfigVersions_async
   */
  listDeviceConfigVersions(
    request?: protos.google.cloud.iot.v1.IListDeviceConfigVersionsRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.iot.v1.IListDeviceConfigVersionsResponse,
      protos.google.cloud.iot.v1.IListDeviceConfigVersionsRequest | undefined,
      {} | undefined
    ]
  >;
  listDeviceConfigVersions(
    request: protos.google.cloud.iot.v1.IListDeviceConfigVersionsRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.cloud.iot.v1.IListDeviceConfigVersionsResponse,
      | protos.google.cloud.iot.v1.IListDeviceConfigVersionsRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  listDeviceConfigVersions(
    request: protos.google.cloud.iot.v1.IListDeviceConfigVersionsRequest,
    callback: Callback<
      protos.google.cloud.iot.v1.IListDeviceConfigVersionsResponse,
      | protos.google.cloud.iot.v1.IListDeviceConfigVersionsRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  listDeviceConfigVersions(
    request?: protos.google.cloud.iot.v1.IListDeviceConfigVersionsRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.cloud.iot.v1.IListDeviceConfigVersionsResponse,
          | protos.google.cloud.iot.v1.IListDeviceConfigVersionsRequest
          | null
          | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.cloud.iot.v1.IListDeviceConfigVersionsResponse,
      | protos.google.cloud.iot.v1.IListDeviceConfigVersionsRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.cloud.iot.v1.IListDeviceConfigVersionsResponse,
      protos.google.cloud.iot.v1.IListDeviceConfigVersionsRequest | undefined,
      {} | undefined
    ]
  > | void {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      const registry = this.getRegistryFromDevicePath(request?.name);
      const region = this.getRegionFromDevicePath(request?.name);
      const deviceName = this.getDeviceNameFromDevicePath(request?.name);
      const token_response = await this.getRegistryToken(registry, region);

      const options = {
        host: token_response.host,
        path:
          '/api/v/4/webhook/execute/' +
          token_response.systemKey +
          '/cloudiot_devices_configVersions?name=' +
          deviceName +
          '&numVersions=' +
          request?.numVersions,
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'ClearBlade-UserToken': token_response.serviceAccountToken,
        },
      };

      const req = https.request(
        {
          ...options,
        },
        res => {
          if (typeof res.statusCode === 'undefined') {
            reject(IoTCoreError(IoTCoreError.KNOWN_ERRORS.NO_STATUS_CODE));
          } else if (isErrorStatusCode(res.statusCode)) {
            let errorData = '';
            res.on('data', chunk => (errorData += chunk));
            res.on('end', () => {
              reject(IoTCoreError(errorData));
            });
          } else {
            let data = '';
            res.on('data', chunk => (data += chunk));
            res.on('end', () => {
              if (!this.isJsonString(data)) {
                reject(data);
                return;
              }
              let array: [
                protos.google.cloud.iot.v1.IListDeviceConfigVersionsResponse,
                (
                  | protos.google.cloud.iot.v1.IListDeviceConfigVersionsRequest
                  | undefined
                ),
                {} | undefined
              ];

              const ilistdeviceconfigversionsresponse: protos.google.cloud.iot.v1.IListDeviceConfigVersionsResponse =
                {};

              const ideviceconfigarray:
                | protos.google.cloud.iot.v1.IDeviceConfig[]
                | null = [];

              const configList = JSON.parse(data);
              //for loop fetching JSON
              for (const index in configList.deviceConfigs) {
                const config: protos.google.cloud.iot.v1.IDeviceConfig = {};
                config.version = configList.deviceConfigs[index].version;
                config.deviceAckTime =
                  configList.deviceConfigs[index].deviceAckTime;
                config.binaryData = configList.deviceConfigs[index].binaryData;
                config.cloudUpdateTime =
                  configList.deviceConfigs[index].cloudUpdateTime;
                ideviceconfigarray.push(config);
              }

              const ilistDeviceconfigversionsrequest: protos.google.cloud.iot.v1.IListDeviceConfigVersionsRequest =
                {};

              ilistdeviceconfigversionsresponse.deviceConfigs =
                ideviceconfigarray;

              // eslint-disable-next-line prefer-const
              array = [
                ilistdeviceconfigversionsresponse,
                ilistDeviceconfigversionsrequest,
                {},
              ];
              resolve(array);
            });
          }
        }
      );
      req.on('error', e => {
        reject(e);
      });
      req.end();
    });
  }
  /**
   * Lists the last few versions of the device state in descending order (i.e.:
   * newest first).
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.name
   *   Required. The name of the device. For example,
   *   `projects/p0/locations/us-central1/registries/registry0/devices/device0` or
   *   `projects/p0/locations/us-central1/registries/registry0/devices/{num_id}`.
   * @param {number} request.numStates
   *   The number of states to list. States are listed in descending order of
   *   update time. The maximum number of states retained is 10. If this
   *   value is zero, it will return all the states available.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [ListDeviceStatesResponse]{@link google.cloud.iot.v1.ListDeviceStatesResponse}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example <caption>include:samples/generated/v1/device_manager.list_device_states.js</caption>
   * region_tag:cloudiot_v1_generated_DeviceManager_ListDeviceStates_async
   */
  listDeviceStates(
    request?: protos.google.cloud.iot.v1.IListDeviceStatesRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.iot.v1.IListDeviceStatesResponse,
      protos.google.cloud.iot.v1.IListDeviceStatesRequest | undefined,
      {} | undefined
    ]
  >;
  listDeviceStates(
    request: protos.google.cloud.iot.v1.IListDeviceStatesRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.cloud.iot.v1.IListDeviceStatesResponse,
      protos.google.cloud.iot.v1.IListDeviceStatesRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  listDeviceStates(
    request: protos.google.cloud.iot.v1.IListDeviceStatesRequest,
    callback: Callback<
      protos.google.cloud.iot.v1.IListDeviceStatesResponse,
      protos.google.cloud.iot.v1.IListDeviceStatesRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  listDeviceStates(
    request?: protos.google.cloud.iot.v1.IListDeviceStatesRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.cloud.iot.v1.IListDeviceStatesResponse,
          | protos.google.cloud.iot.v1.IListDeviceStatesRequest
          | null
          | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.cloud.iot.v1.IListDeviceStatesResponse,
      protos.google.cloud.iot.v1.IListDeviceStatesRequest | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.cloud.iot.v1.IListDeviceStatesResponse,
      protos.google.cloud.iot.v1.IListDeviceStatesRequest | undefined,
      {} | undefined
    ]
  > | void {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      const registry = this.getRegistryFromDevicePath(request?.name);
      const region = this.getRegionFromDevicePath(request?.name);
      const deviceName = this.getDeviceNameFromDevicePath(request?.name);
      const token_response = await this.getRegistryToken(registry, region);

      const options = {
        host: token_response.host,
        port: '443',
        path:
          `/api/v/4/webhook/execute/` +
          token_response.systemKey +
          `/cloudiot_devices_states?name=` +
          deviceName +
          `&numStates=` +
          request?.numStates,
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'ClearBlade-UserToken': token_response.serviceAccountToken,
        },
      };

      const req = https.request(
        {
          ...options,
        },
        res => {
          if (typeof res.statusCode === 'undefined') {
            reject(IoTCoreError(IoTCoreError.KNOWN_ERRORS.NO_STATUS_CODE));
          } else if (isErrorStatusCode(res.statusCode)) {
            let errorData = '';
            res.on('data', chunk => (errorData += chunk));
            res.on('end', () => {
              reject(IoTCoreError(errorData));
            });
          } else {
            let data = '';
            const chunks: any[] = [];
            res.on('data', chunk => (data += chunk));
            res.on('end', () => {
              if (!this.isJsonString(data)) {
                reject(data);
                return;
              }
              let array: [
                protos.google.cloud.iot.v1.IListDeviceStatesResponse,
                protos.google.cloud.iot.v1.IListDeviceStatesRequest | undefined,
                {} | undefined
              ];
              const request:
                | protos.google.cloud.iot.v1.IListDeviceStatesRequest
                | undefined = {};
              const deviceStatesRes = JSON.parse(data);
              const deviceStateObj: protos.google.cloud.iot.v1.IDeviceState =
                {};
              const deviceStateArray:
                | protos.google.cloud.iot.v1.IDeviceState[]
                | null = [];
              const response: protos.google.cloud.iot.v1.IListDeviceStatesResponse =
                {};
              for (const index in deviceStatesRes.deviceStates) {
                deviceStateObj.updateTime =
                  deviceStatesRes.deviceStates[index].updateTime;
                deviceStateObj.binaryData =
                  deviceStatesRes.deviceStates[index].binaryData;
                deviceStateArray.push(deviceStateObj);
              }
              response.deviceStates = deviceStateArray;
              // eslint-disable-next-line prefer-const
              array = [response, request, {}];
              resolve(array);
            });
          }
        }
      );
      req.on('error', e => {
        console.log('error: ', e);
        reject(e);
      });
      req.end();
    });
  }
  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.resource
   *   REQUIRED: The resource for which the policy is being specified.
   *   See the operation documentation for the appropriate value for this field.
   * @param {google.iam.v1.Policy} request.policy
   *   REQUIRED: The complete policy to be applied to the `resource`. The size of
   *   the policy is limited to a few 10s of KB. An empty policy is a
   *   valid policy but certain Cloud Platform services (such as Projects)
   *   might reject them.
   * @param {google.protobuf.FieldMask} request.updateMask
   *   OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only
   *   the fields in the mask will be modified. If no mask is provided, the
   *   following default mask is used:
   *
   *   `paths: "bindings, etag"`
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [Policy]{@link google.iam.v1.Policy}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example <caption>include:samples/generated/v1/device_manager.set_iam_policy.js</caption>
   * region_tag:cloudiot_v1_generated_DeviceManager_SetIamPolicy_async
   */
  setIamPolicy(
    request?: protos.google.iam.v1.ISetIamPolicyRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.iam.v1.IPolicy,
      protos.google.iam.v1.ISetIamPolicyRequest | undefined,
      {} | undefined
    ]
  >;
  setIamPolicy(
    request: protos.google.iam.v1.ISetIamPolicyRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.iam.v1.IPolicy,
      protos.google.iam.v1.ISetIamPolicyRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  setIamPolicy(
    request: protos.google.iam.v1.ISetIamPolicyRequest,
    callback: Callback<
      protos.google.iam.v1.IPolicy,
      protos.google.iam.v1.ISetIamPolicyRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  setIamPolicy(
    request?: protos.google.iam.v1.ISetIamPolicyRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.iam.v1.IPolicy,
          protos.google.iam.v1.ISetIamPolicyRequest | null | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.iam.v1.IPolicy,
      protos.google.iam.v1.ISetIamPolicyRequest | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.iam.v1.IPolicy,
      protos.google.iam.v1.ISetIamPolicyRequest | undefined,
      {} | undefined
    ]
  > | void {
    // request = request || {};
    // let options: CallOptions;
    // if (typeof optionsOrCallback === 'function' && callback === undefined) {
    //   callback = optionsOrCallback;
    //   options = {};
    // } else {
    //   options = optionsOrCallback as CallOptions;
    // }
    // options = options || {};
    // options.otherArgs = options.otherArgs || {};
    // options.otherArgs.headers = options.otherArgs.headers || {};
    // options.otherArgs.headers['x-goog-request-params'] =
    //   this._gaxModule.routingHeader.fromParams({
    //     resource: request.resource || '',
    //   });
    // this.initialize();
    // return this.innerApiCalls.setIamPolicy(request, options, callback);
    return undefined;
  }
  /**
   * Gets the access control policy for a resource.
   * Returns an empty policy if the resource exists and does not have a policy
   * set.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.resource
   *   REQUIRED: The resource for which the policy is being requested.
   *   See the operation documentation for the appropriate value for this field.
   * @param {google.iam.v1.GetPolicyOptions} request.options
   *   OPTIONAL: A `GetPolicyOptions` object for specifying options to
   *   `GetIamPolicy`.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [Policy]{@link google.iam.v1.Policy}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example <caption>include:samples/generated/v1/device_manager.get_iam_policy.js</caption>
   * region_tag:cloudiot_v1_generated_DeviceManager_GetIamPolicy_async
   */
  getIamPolicy(
    request?: protos.google.iam.v1.IGetIamPolicyRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.iam.v1.IPolicy,
      protos.google.iam.v1.IGetIamPolicyRequest | undefined,
      {} | undefined
    ]
  >;
  getIamPolicy(
    request: protos.google.iam.v1.IGetIamPolicyRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.iam.v1.IPolicy,
      protos.google.iam.v1.IGetIamPolicyRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  getIamPolicy(
    request: protos.google.iam.v1.IGetIamPolicyRequest,
    callback: Callback<
      protos.google.iam.v1.IPolicy,
      protos.google.iam.v1.IGetIamPolicyRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  getIamPolicy(
    request?: protos.google.iam.v1.IGetIamPolicyRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.iam.v1.IPolicy,
          protos.google.iam.v1.IGetIamPolicyRequest | null | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.iam.v1.IPolicy,
      protos.google.iam.v1.IGetIamPolicyRequest | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.iam.v1.IPolicy,
      protos.google.iam.v1.IGetIamPolicyRequest | undefined,
      {} | undefined
    ]
  > | void {
    // request = request || {};
    // let options: CallOptions;
    // if (typeof optionsOrCallback === 'function' && callback === undefined) {
    //   callback = optionsOrCallback;
    //   options = {};
    // } else {
    //   options = optionsOrCallback as CallOptions;
    // }
    // options = options || {};
    // options.otherArgs = options.otherArgs || {};
    // options.otherArgs.headers = options.otherArgs.headers || {};
    // options.otherArgs.headers['x-goog-request-params'] =
    //   this._gaxModule.routingHeader.fromParams({
    //     resource: request.resource || '',
    //   });
    // this.initialize();
    // return this.innerApiCalls.getIamPolicy(request, options, callback);
    return undefined;
  }
  /**
   * Returns permissions that a caller has on the specified resource.
   * If the resource does not exist, this will return an empty set of
   * permissions, not a NOT_FOUND error.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.resource
   *   REQUIRED: The resource for which the policy detail is being requested.
   *   See the operation documentation for the appropriate value for this field.
   * @param {string[]} request.permissions
   *   The set of permissions to check for the `resource`. Permissions with
   *   wildcards (such as '*' or 'storage.*') are not allowed. For more
   *   information see
   *   [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [TestIamPermissionsResponse]{@link google.iam.v1.TestIamPermissionsResponse}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example <caption>include:samples/generated/v1/device_manager.test_iam_permissions.js</caption>
   * region_tag:cloudiot_v1_generated_DeviceManager_TestIamPermissions_async
   */
  testIamPermissions(
    request?: protos.google.iam.v1.ITestIamPermissionsRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.iam.v1.ITestIamPermissionsResponse,
      protos.google.iam.v1.ITestIamPermissionsRequest | undefined,
      {} | undefined
    ]
  >;
  testIamPermissions(
    request: protos.google.iam.v1.ITestIamPermissionsRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.iam.v1.ITestIamPermissionsResponse,
      protos.google.iam.v1.ITestIamPermissionsRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  testIamPermissions(
    request: protos.google.iam.v1.ITestIamPermissionsRequest,
    callback: Callback<
      protos.google.iam.v1.ITestIamPermissionsResponse,
      protos.google.iam.v1.ITestIamPermissionsRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  testIamPermissions(
    request?: protos.google.iam.v1.ITestIamPermissionsRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.iam.v1.ITestIamPermissionsResponse,
          protos.google.iam.v1.ITestIamPermissionsRequest | null | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.iam.v1.ITestIamPermissionsResponse,
      protos.google.iam.v1.ITestIamPermissionsRequest | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.iam.v1.ITestIamPermissionsResponse,
      protos.google.iam.v1.ITestIamPermissionsRequest | undefined,
      {} | undefined
    ]
  > | void {
    // request = request || {};
    // let options: CallOptions;
    // if (typeof optionsOrCallback === 'function' && callback === undefined) {
    //   callback = optionsOrCallback;
    //   options = {};
    // } else {
    //   options = optionsOrCallback as CallOptions;
    // }
    // options = options || {};
    // options.otherArgs = options.otherArgs || {};
    // options.otherArgs.headers = options.otherArgs.headers || {};
    // options.otherArgs.headers['x-goog-request-params'] =
    //   this._gaxModule.routingHeader.fromParams({
    //     resource: request.resource || '',
    //   });
    // this.initialize();
    // return this.innerApiCalls.testIamPermissions(request, options, callback);
    return undefined;
  }
  /**
   * Sends a command to the specified device. In order for a device to be able
   * to receive commands, it must:
   * 1) be connected to Cloud IoT Core using the MQTT protocol, and
   * 2) be subscribed to the group of MQTT topics specified by
   *    /devices/{device-id}/commands/#. This subscription will receive commands
   *    at the top-level topic /devices/{device-id}/commands as well as commands
   *    for subfolders, like /devices/{device-id}/commands/subfolder.
   *    Note that subscribing to specific subfolders is not supported.
   * If the command could not be delivered to the device, this method will
   * return an error; in particular, if the device is not subscribed, this
   * method will return FAILED_PRECONDITION. Otherwise, this method will
   * return OK. If the subscription is QoS 1, at least once delivery will be
   * guaranteed; for QoS 0, no acknowledgment will be expected from the device.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.name
   *   Required. The name of the device. For example,
   *   `projects/p0/locations/us-central1/registries/registry0/devices/device0` or
   *   `projects/p0/locations/us-central1/registries/registry0/devices/{num_id}`.
   * @param {Buffer} request.binaryData
   *   Required. The command data to send to the device.
   * @param {string} request.subfolder
   *   Optional subfolder for the command. If empty, the command will be delivered
   *   to the /devices/{device-id}/commands topic, otherwise it will be delivered
   *   to the /devices/{device-id}/commands/{subfolder} topic. Multi-level
   *   subfolders are allowed. This field must not have more than 256 characters,
   *   and must not contain any MQTT wildcards ("+" or "#") or null characters.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [SendCommandToDeviceResponse]{@link google.cloud.iot.v1.SendCommandToDeviceResponse}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example <caption>include:samples/generated/v1/device_manager.send_command_to_device.js</caption>
   * region_tag:cloudiot_v1_generated_DeviceManager_SendCommandToDevice_async
   */
  sendCommandToDevice(
    request?: protos.google.cloud.iot.v1.ISendCommandToDeviceRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.iot.v1.ISendCommandToDeviceResponse,
      protos.google.cloud.iot.v1.ISendCommandToDeviceRequest | undefined,
      {} | undefined
    ]
  >;
  sendCommandToDevice(
    request: protos.google.cloud.iot.v1.ISendCommandToDeviceRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.cloud.iot.v1.ISendCommandToDeviceResponse,
      protos.google.cloud.iot.v1.ISendCommandToDeviceRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  sendCommandToDevice(
    request: protos.google.cloud.iot.v1.ISendCommandToDeviceRequest,
    callback: Callback<
      protos.google.cloud.iot.v1.ISendCommandToDeviceResponse,
      protos.google.cloud.iot.v1.ISendCommandToDeviceRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  sendCommandToDevice(
    request?: protos.google.cloud.iot.v1.ISendCommandToDeviceRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.cloud.iot.v1.ISendCommandToDeviceResponse,
          | protos.google.cloud.iot.v1.ISendCommandToDeviceRequest
          | null
          | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.cloud.iot.v1.ISendCommandToDeviceResponse,
      protos.google.cloud.iot.v1.ISendCommandToDeviceRequest | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.cloud.iot.v1.ISendCommandToDeviceResponse,
      protos.google.cloud.iot.v1.ISendCommandToDeviceRequest | undefined,
      {} | undefined
    ]
  > | void {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      const registry = this.getRegistryFromDevicePath(request?.name);
      const region = this.getRegionFromDevicePath(request?.name);
      const deviceName = this.getDeviceNameFromDevicePath(request?.name);

      const token_response = await this.getRegistryToken(registry, region);

      const payload = JSON.stringify({
        binaryData: request?.binaryData,
        subfolder: request?.subfolder,
      });
      const options = {
        host: token_response.host,
        port: '443',
        path: `/api/v/4/webhook/execute/${token_response.systemKey}/cloudiot_devices?method=sendCommandToDevice&name=${deviceName}`,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'ClearBlade-UserToken': token_response.serviceAccountToken,
          'Content-Length': payload.length,
        },
      };

      const req = https.request(
        {
          ...options,
        },
        res => {
          if (typeof res.statusCode === 'undefined') {
            reject(IoTCoreError(IoTCoreError.KNOWN_ERRORS.NO_STATUS_CODE));
          } else if (isErrorStatusCode(res.statusCode)) {
            let errorData = '';
            res.on('data', chunk => (errorData += chunk));
            res.on('end', () => {
              reject(IoTCoreError(errorData));
            });
          } else {
            let data = '';
            res.on('data', chunk => (data += chunk));
            res.on('end', () => {
              let array: [
                protos.google.cloud.iot.v1.ISendCommandToDeviceResponse,
                (
                  | protos.google.cloud.iot.v1.ISendCommandToDeviceRequest
                  | undefined
                ),
                {} | undefined
              ];

              const isendcommandtodevicerequest:
                | protos.google.cloud.iot.v1.ISendCommandToDeviceRequest
                | undefined = {};
              const isendcommandtodeviceresponse: protos.google.cloud.iot.v1.ISendCommandToDeviceResponse =
                {};
              // eslint-disable-next-line prefer-const
              array = [
                isendcommandtodevicerequest,
                isendcommandtodeviceresponse,
                {},
              ];
              resolve(array);
            });
          }
        }
      );
      req.on('error', e => {
        reject(e);
      });
      if (payload) {
        req.write(payload);
      }
      req.end();
    });
  }
  /**
   * Associates the device with the gateway.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The name of the registry. For example,
   *   `projects/example-project/locations/us-central1/registries/my-registry`.
   * @param {string} request.gatewayId
   *   Required. The value of `gateway_id` can be either the device numeric ID or the
   *   user-defined device identifier.
   * @param {string} request.deviceId
   *   Required. The device to associate with the specified gateway. The value of
   *   `device_id` can be either the device numeric ID or the user-defined device
   *   identifier.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [BindDeviceToGatewayResponse]{@link google.cloud.iot.v1.BindDeviceToGatewayResponse}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example <caption>include:samples/generated/v1/device_manager.bind_device_to_gateway.js</caption>
   * region_tag:cloudiot_v1_generated_DeviceManager_BindDeviceToGateway_async
   */
  bindDeviceToGateway(
    request?: protos.google.cloud.iot.v1.IBindDeviceToGatewayRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.iot.v1.IBindDeviceToGatewayResponse,
      protos.google.cloud.iot.v1.IBindDeviceToGatewayRequest | undefined,
      {} | undefined
    ]
  >;
  bindDeviceToGateway(
    request: protos.google.cloud.iot.v1.IBindDeviceToGatewayRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.cloud.iot.v1.IBindDeviceToGatewayResponse,
      protos.google.cloud.iot.v1.IBindDeviceToGatewayRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  bindDeviceToGateway(
    request: protos.google.cloud.iot.v1.IBindDeviceToGatewayRequest,
    callback: Callback<
      protos.google.cloud.iot.v1.IBindDeviceToGatewayResponse,
      protos.google.cloud.iot.v1.IBindDeviceToGatewayRequest | null | undefined,
      {} | null | undefined
    >
  ): void;
  bindDeviceToGateway(
    request?: protos.google.cloud.iot.v1.IBindDeviceToGatewayRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.cloud.iot.v1.IBindDeviceToGatewayResponse,
          | protos.google.cloud.iot.v1.IBindDeviceToGatewayRequest
          | null
          | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.cloud.iot.v1.IBindDeviceToGatewayResponse,
      protos.google.cloud.iot.v1.IBindDeviceToGatewayRequest | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.cloud.iot.v1.IBindDeviceToGatewayResponse,
      protos.google.cloud.iot.v1.IBindDeviceToGatewayRequest | undefined,
      {} | undefined
    ]
  > | void {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      const registry = this.getRegistryFromRegistryPath(request?.parent);
      const region = this.getRegionFromRegistryPath(request?.parent);
      const token_response = await this.getRegistryToken(registry, region);

      const payload = JSON.stringify({
        gatewayId: request?.gatewayId,
        deviceId: request?.deviceId,
      });
      const options = {
        host: token_response.host,
        path:
          '/api/v/4/webhook/execute/' +
          token_response.systemKey +
          '/cloudiot?method=bindDeviceToGateway',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'ClearBlade-UserToken': token_response.serviceAccountToken,
          'Content-Length': payload.length,
        },
      };

      const req = https.request(
        {
          ...options,
        },
        res => {
          if (typeof res.statusCode === 'undefined') {
            reject(IoTCoreError(IoTCoreError.KNOWN_ERRORS.NO_STATUS_CODE));
          } else if (isErrorStatusCode(res.statusCode)) {
            let errorData = '';
            res.on('data', chunk => (errorData += chunk));
            res.on('end', () => {
              reject(IoTCoreError(errorData));
            });
          } else {
            let data = '';
            const chunks: any[] = [];
            res.on('data', chunk => (data += chunk));
            res.on('end', () => {
              // eslint-disable-next-line eqeqeq
              if (data != '' && !this.isJsonString(data)) {
                reject(data);
                return;
              }
              let array: [
                protos.google.cloud.iot.v1.IBindDeviceToGatewayResponse,
                (
                  | protos.google.cloud.iot.v1.IBindDeviceToGatewayRequest
                  | undefined
                ),
                {} | undefined
              ];
              const imodifycloudtodeviceconfigrequest:
                | protos.google.cloud.iot.v1.IBindDeviceToGatewayRequest
                | undefined = {};
              const ibinddevicetogatewayresponse: protos.google.cloud.iot.v1.IBindDeviceToGatewayResponse =
                {};
              // eslint-disable-next-line prefer-const
              array = [
                ibinddevicetogatewayresponse,
                imodifycloudtodeviceconfigrequest,
                {},
              ];
              resolve(array);
            });
          }
        }
      );
      req.on('error', e => {
        console.log('error: ', e);
        reject(e);
      });
      if (payload) {
        req.write(payload);
      }
      req.end();
    });
  }
  /**
   * Deletes the association between the device and the gateway.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The name of the registry. For example,
   *   `projects/example-project/locations/us-central1/registries/my-registry`.
   * @param {string} request.gatewayId
   *   Required. The value of `gateway_id` can be either the device numeric ID or the
   *   user-defined device identifier.
   * @param {string} request.deviceId
   *   Required. The device to disassociate from the specified gateway. The value of
   *   `device_id` can be either the device numeric ID or the user-defined device
   *   identifier.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [UnbindDeviceFromGatewayResponse]{@link google.cloud.iot.v1.UnbindDeviceFromGatewayResponse}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example <caption>include:samples/generated/v1/device_manager.unbind_device_from_gateway.js</caption>
   * region_tag:cloudiot_v1_generated_DeviceManager_UnbindDeviceFromGateway_async
   */
  unbindDeviceFromGateway(
    request?: protos.google.cloud.iot.v1.IUnbindDeviceFromGatewayRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.iot.v1.IUnbindDeviceFromGatewayResponse,
      protos.google.cloud.iot.v1.IUnbindDeviceFromGatewayRequest | undefined,
      {} | undefined
    ]
  >;
  unbindDeviceFromGateway(
    request: protos.google.cloud.iot.v1.IUnbindDeviceFromGatewayRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.cloud.iot.v1.IUnbindDeviceFromGatewayResponse,
      | protos.google.cloud.iot.v1.IUnbindDeviceFromGatewayRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  unbindDeviceFromGateway(
    request: protos.google.cloud.iot.v1.IUnbindDeviceFromGatewayRequest,
    callback: Callback<
      protos.google.cloud.iot.v1.IUnbindDeviceFromGatewayResponse,
      | protos.google.cloud.iot.v1.IUnbindDeviceFromGatewayRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  unbindDeviceFromGateway(
    request?: protos.google.cloud.iot.v1.IUnbindDeviceFromGatewayRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.cloud.iot.v1.IUnbindDeviceFromGatewayResponse,
          | protos.google.cloud.iot.v1.IUnbindDeviceFromGatewayRequest
          | null
          | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.cloud.iot.v1.IUnbindDeviceFromGatewayResponse,
      | protos.google.cloud.iot.v1.IUnbindDeviceFromGatewayRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.cloud.iot.v1.IUnbindDeviceFromGatewayResponse,
      protos.google.cloud.iot.v1.IUnbindDeviceFromGatewayRequest | undefined,
      {} | undefined
    ]
  > | void {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      const registry = this.getRegistryFromRegistryPath(request?.parent);
      const region = this.getRegionFromRegistryPath(request?.parent);
      const token_response = await this.getRegistryToken(registry, region);

      const payload = JSON.stringify({
        gatewayId: request?.gatewayId,
        deviceId: request?.deviceId,
      });
      const options = {
        host: token_response.host,
        path:
          '/api/v/4/webhook/execute/' +
          token_response.systemKey +
          '/cloudiot?method=unbindDeviceFromGateway',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'ClearBlade-UserToken': token_response.serviceAccountToken,
          'Content-Length': payload.length,
        },
      };

      const req = https.request(
        {
          ...options,
        },
        res => {
          if (typeof res.statusCode === 'undefined') {
            reject(IoTCoreError(IoTCoreError.KNOWN_ERRORS.NO_STATUS_CODE));
          } else if (isErrorStatusCode(res.statusCode)) {
            let errorData = '';
            res.on('data', chunk => (errorData += chunk));
            res.on('end', () => {
              reject(IoTCoreError(errorData));
            });
          } else {
            let data = '';
            const chunks: any[] = [];
            res.on('data', chunk => (data += chunk));
            res.on('end', () => {
              let array: [
                protos.google.cloud.iot.v1.IUnbindDeviceFromGatewayResponse,
                (
                  | protos.google.cloud.iot.v1.IUnbindDeviceFromGatewayRequest
                  | undefined
                ),
                {} | undefined
              ];
              const request:
                | protos.google.cloud.iot.v1.IUnbindDeviceFromGatewayRequest
                | undefined = {};
              const response: protos.google.cloud.iot.v1.IUnbindDeviceFromGatewayResponse =
                {};
              // eslint-disable-next-line prefer-const
              array = [response, request, {}];
              resolve(array);
            });
          }
        }
      );
      req.on('error', e => {
        console.log('error: ', e);
        reject(e);
      });
      if (payload) {
        req.write(payload);
      }
      req.end();
    });
  }

  /**
   * Lists device registries.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The project and cloud region path. For example,
   *   `projects/example-project/locations/us-central1`.
   * @param {number} request.pageSize
   *   The maximum number of registries to return in the response. If this value
   *   is zero, the service will select a default size. A call may return fewer
   *   objects than requested. A non-empty `next_page_token` in the response
   *   indicates that more data is available.
   * @param {string} request.pageToken
   *   The value returned by the last `ListDeviceRegistriesResponse`; indicates
   *   that this is a continuation of a prior `ListDeviceRegistries` call and
   *   the system should return the next page of data.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is Array of [DeviceRegistry]{@link google.cloud.iot.v1.DeviceRegistry}.
   *   The client library will perform auto-pagination by default: it will call the API as many
   *   times as needed and will merge results from all the pages into this array.
   *   Note that it can affect your quota.
   *   We recommend using `listDeviceRegistriesAsync()`
   *   method described below for async iteration which you can stop as needed.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination)
   *   for more details and examples.
   */
  listDeviceRegistries(
    request?: protos.google.cloud.iot.v1.IListDeviceRegistriesRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.iot.v1.IDeviceRegistry[],
      protos.google.cloud.iot.v1.IListDeviceRegistriesRequest | null,
      protos.google.cloud.iot.v1.IListDeviceRegistriesResponse
    ]
  >;
  listDeviceRegistries(
    request: protos.google.cloud.iot.v1.IListDeviceRegistriesRequest,
    options: CallOptions,
    callback: PaginationCallback<
      protos.google.cloud.iot.v1.IListDeviceRegistriesRequest,
      | protos.google.cloud.iot.v1.IListDeviceRegistriesResponse
      | null
      | undefined,
      protos.google.cloud.iot.v1.IDeviceRegistry
    >
  ): void;
  listDeviceRegistries(
    request: protos.google.cloud.iot.v1.IListDeviceRegistriesRequest,
    callback: PaginationCallback<
      protos.google.cloud.iot.v1.IListDeviceRegistriesRequest,
      | protos.google.cloud.iot.v1.IListDeviceRegistriesResponse
      | null
      | undefined,
      protos.google.cloud.iot.v1.IDeviceRegistry
    >
  ): void;
  listDeviceRegistries(
    request?: protos.google.cloud.iot.v1.IListDeviceRegistriesRequest,
    optionsOrCallback?:
      | CallOptions
      | PaginationCallback<
          protos.google.cloud.iot.v1.IListDeviceRegistriesRequest,
          | protos.google.cloud.iot.v1.IListDeviceRegistriesResponse
          | null
          | undefined,
          protos.google.cloud.iot.v1.IDeviceRegistry
        >,
    callback?: PaginationCallback<
      protos.google.cloud.iot.v1.IListDeviceRegistriesRequest,
      | protos.google.cloud.iot.v1.IListDeviceRegistriesResponse
      | null
      | undefined,
      protos.google.cloud.iot.v1.IDeviceRegistry
    >
  ): Promise<
    [
      protos.google.cloud.iot.v1.IDeviceRegistry[],
      protos.google.cloud.iot.v1.IListDeviceRegistriesRequest | null,
      protos.google.cloud.iot.v1.IListDeviceRegistriesResponse
    ]
  > | void {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      const options = {
        host: this.BASE_URL,
        path:
          '/api/v/4/webhook/execute/' +
          this.ADMIN_SYSTEM_KEY +
          '/cloudiot?parent=' +
          request?.parent,
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'ClearBlade-UserToken': this.ADMIN_USER_TOKEN,
        },
      };

      const req = https.request(
        {
          ...options,
        },
        res => {
          if (typeof res.statusCode === 'undefined') {
            reject(IoTCoreError(IoTCoreError.KNOWN_ERRORS.NO_STATUS_CODE));
          } else if (isErrorStatusCode(res.statusCode)) {
            let errorData = '';
            res.on('data', chunk => (errorData += chunk));
            res.on('end', () => {
              reject(IoTCoreError(errorData));
            });
          } else {
            let data = '';
            res.on('data', chunk => (data += chunk));
            res.on('end', () => {
              const deviceRegistries: protos.google.cloud.iot.v1.IDeviceRegistry[] =
                JSON.parse(data).deviceRegistries;
              const nextPageToken: string =
                JSON.parse(data).nextPageToken || '0';
              resolve([
                deviceRegistries,
                null,
                {deviceRegistries, nextPageToken},
              ]);
            });
          }
        }
      );
      req.on('error', e => {
        reject(e);
      });
      req.end();
    });
  }

  async getRegistryToken(
    registry: string,
    region: string
  ): Promise<GetRegistryCredentialsResponse & {host: string}> {
    const payload = JSON.stringify({
      region: region,
      registry: registry,
      project: this.PROJECT_ID,
    });
    return new Promise<GetRegistryCredentialsResponse & {host: string}>(
      (resolve, reject) => {
        const options = {
          host: this.BASE_URL,
          path: `/api/v/1/code/${this.ADMIN_SYSTEM_KEY}/getRegistryCredentials`,
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'ClearBlade-UserToken': this.ADMIN_USER_TOKEN,
            'Content-Length': payload.length,
          },
        };
        const req = https.request(options, res => {
          let data = '';
          res.on('data', chunk => (data += chunk));
          res.on('end', () => {
            try {
              const parsed = JSON.parse(data);
              if (!isGetRegistryCredentialsResponse(parsed)) {
                reject(
                  IoTCoreError(
                    'Invalid response from getRegistryCredentials:' + data
                  )
                );
              } else {
                const regionalURL = new URL(parsed.url);
                resolve({
                  ...parsed,
                  host: regionalURL.host,
                });
              }
            } catch (e) {
              reject(
                IoTCoreError(
                  'Caught error while parsing response from getRegistryCredentials: ' +
                    e
                )
              );
            }
          });
        });
        req.on('error', e => {
          reject(e);
        });
        req.write(payload);
        req.end();
      }
    );
  }

  /**
   * Equivalent to `method.name.toCamelCase()`, but returns a NodeJS Stream object.
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The project and cloud region path. For example,
   *   `projects/example-project/locations/us-central1`.
   * @param {number} request.pageSize
   *   The maximum number of registries to return in the response. If this value
   *   is zero, the service will select a default size. A call may return fewer
   *   objects than requested. A non-empty `next_page_token` in the response
   *   indicates that more data is available.
   * @param {string} request.pageToken
   *   The value returned by the last `ListDeviceRegistriesResponse`; indicates
   *   that this is a continuation of a prior `ListDeviceRegistries` call and
   *   the system should return the next page of data.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Stream}
   *   An object stream which emits an object representing [DeviceRegistry]{@link google.cloud.iot.v1.DeviceRegistry} on 'data' event.
   *   The client library will perform auto-pagination by default: it will call the API as many
   *   times as needed. Note that it can affect your quota.
   *   We recommend using `listDeviceRegistriesAsync()`
   *   method described below for async iteration which you can stop as needed.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination)
   *   for more details and examples.
   */
  // listDeviceRegistriesStream(
  //   request?: protos.google.cloud.iot.v1.IListDeviceRegistriesRequest,
  //   options?: CallOptions
  // ): Transform {
  // request = request || {};
  // options = options || {};
  // options.otherArgs = options.otherArgs || {};
  // options.otherArgs.headers = options.otherArgs.headers || {};
  // options.otherArgs.headers['x-goog-request-params'] =
  //   this._gaxModule.routingHeader.fromParams({
  //     parent: request.parent || '',
  //   });
  // const defaultCallSettings = this._defaults['listDeviceRegistries'];
  // const callSettings = defaultCallSettings.merge(options);
  // this.initialize();
  // return this.descriptors.page.listDeviceRegistries.createStream(
  //   this.innerApiCalls.listDeviceRegistries as GaxCall,
  //   request,
  //   callSettings
  // );
  //}

  /**
   * Equivalent to `listDeviceRegistries`, but returns an iterable object.
   *
   * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The project and cloud region path. For example,
   *   `projects/example-project/locations/us-central1`.
   * @param {number} request.pageSize
   *   The maximum number of registries to return in the response. If this value
   *   is zero, the service will select a default size. A call may return fewer
   *   objects than requested. A non-empty `next_page_token` in the response
   *   indicates that more data is available.
   * @param {string} request.pageToken
   *   The value returned by the last `ListDeviceRegistriesResponse`; indicates
   *   that this is a continuation of a prior `ListDeviceRegistries` call and
   *   the system should return the next page of data.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Object}
   *   An iterable Object that allows [async iteration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).
   *   When you iterate the returned iterable, each element will be an object representing
   *   [DeviceRegistry]{@link google.cloud.iot.v1.DeviceRegistry}. The API will be called under the hood as needed, once per the page,
   *   so you can stop the iteration when you don't need more results.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination)
   *   for more details and examples.
   * @example <caption>include:samples/generated/v1/device_manager.list_device_registries.js</caption>
   * region_tag:cloudiot_v1_generated_DeviceManager_ListDeviceRegistries_async
   */
  // listDeviceRegistriesAsync(
  //   request?: protos.google.cloud.iot.v1.IListDeviceRegistriesRequest,
  //   options?: CallOptions
  // ): AsyncIterable<protos.google.cloud.iot.v1.IDeviceRegistry> {
  //   request = request || {};
  //   options = options || {};
  //   options.otherArgs = options.otherArgs || {};
  //   options.otherArgs.headers = options.otherArgs.headers || {};
  //   options.otherArgs.headers['x-goog-request-params'] =
  //     this._gaxModule.routingHeader.fromParams({
  //       parent: request.parent || '',
  //     });
  //   const defaultCallSettings = this._defaults['listDeviceRegistries'];
  //   const callSettings = defaultCallSettings.merge(options);
  //   this.initialize();
  //   return this.descriptors.page.listDeviceRegistries.asyncIterate(
  //     this.innerApiCalls['listDeviceRegistries'] as GaxCall,
  //     request as {},
  //     callSettings
  //   ) as AsyncIterable<protos.google.cloud.iot.v1.IDeviceRegistry>;
  // }
  /**
   * List devices in a device registry.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The device registry path. Required. For example,
   *   `projects/my-project/locations/us-central1/registries/my-registry`.
   * @param {number[]} request.deviceNumIds
   *   A list of device numeric IDs. If empty, this field is ignored. Maximum
   *   IDs: 10,000.
   * @param {string[]} request.deviceIds
   *   A list of device string IDs. For example, `['device0', 'device12']`.
   *   If empty, this field is ignored. Maximum IDs: 10,000
   * @param {google.protobuf.FieldMask} request.fieldMask
   *   The fields of the `Device` resource to be returned in the response. The
   *   fields `id` and `num_id` are always returned, along with any
   *   other fields specified in snake_case format, for example:
   *   `last_heartbeat_time`.
   * @param {google.cloud.iot.v1.GatewayListOptions} request.gatewayListOptions
   *   Options related to gateways.
   * @param {number} request.pageSize
   *   The maximum number of devices to return in the response. If this value
   *   is zero, the service will select a default size. A call may return fewer
   *   objects than requested. A non-empty `next_page_token` in the response
   *   indicates that more data is available.
   * @param {string} request.pageToken
   *   The value returned by the last `ListDevicesResponse`; indicates
   *   that this is a continuation of a prior `ListDevices` call and
   *   the system should return the next page of data.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is Array of [Device]{@link google.cloud.iot.v1.Device}.
   *   The client library will perform auto-pagination by default: it will call the API as many
   *   times as needed and will merge results from all the pages into this array.
   *   Note that it can affect your quota.
   *   We recommend using `listDevicesAsync()`
   *   method described below for async iteration which you can stop as needed.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination)
   *   for more details and examples.
   */
  listDevices(
    request?: protos.google.cloud.iot.v1.IListDevicesRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.iot.v1.IDevice[],
      protos.google.cloud.iot.v1.IListDevicesRequest | null,
      protos.google.cloud.iot.v1.IListDevicesResponse
    ]
  >;
  listDevices(
    request: protos.google.cloud.iot.v1.IListDevicesRequest,
    options: CallOptions,
    callback: PaginationCallback<
      protos.google.cloud.iot.v1.IListDevicesRequest,
      protos.google.cloud.iot.v1.IListDevicesResponse | null | undefined,
      protos.google.cloud.iot.v1.IDevice
    >
  ): void;
  listDevices(
    request: protos.google.cloud.iot.v1.IListDevicesRequest,
    callback: PaginationCallback<
      protos.google.cloud.iot.v1.IListDevicesRequest,
      protos.google.cloud.iot.v1.IListDevicesResponse | null | undefined,
      protos.google.cloud.iot.v1.IDevice
    >
  ): void;
  listDevices(
    request?: protos.google.cloud.iot.v1.IListDevicesRequest,
    optionsOrCallback?:
      | CallOptions
      | PaginationCallback<
          protos.google.cloud.iot.v1.IListDevicesRequest,
          protos.google.cloud.iot.v1.IListDevicesResponse | null | undefined,
          protos.google.cloud.iot.v1.IDevice
        >,
    callback?: PaginationCallback<
      protos.google.cloud.iot.v1.IListDevicesRequest,
      protos.google.cloud.iot.v1.IListDevicesResponse | null | undefined,
      protos.google.cloud.iot.v1.IDevice
    >
  ): Promise<
    [
      protos.google.cloud.iot.v1.IDevice[],
      protos.google.cloud.iot.v1.IListDevicesRequest | null,
      protos.google.cloud.iot.v1.IListDevicesResponse
    ]
  > | void {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      const registry = this.getRegistryFromRegistryPath(request?.parent);
      const region = this.getRegionFromRegistryPath(request?.parent);
      const token_response = await this.getRegistryToken(registry, region);

      const payload = JSON.stringify({
        parent: request?.parent,
      });

      const options = {
        host: token_response.host,
        path:
          '/api/v/4/webhook/execute/' +
          token_response.systemKey +
          '/cloudiot_devices?parent=' +
          request?.parent,
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'ClearBlade-UserToken': token_response.serviceAccountToken,
          'Content-Length': payload.length,
        },
      };

      const req = https.request(
        {
          ...options,
        },
        res => {
          if (typeof res.statusCode === 'undefined') {
            reject(IoTCoreError(IoTCoreError.KNOWN_ERRORS.NO_STATUS_CODE));
          } else if (isErrorStatusCode(res.statusCode)) {
            let errorData = '';
            res.on('data', chunk => (errorData += chunk));
            res.on('end', () => {
              reject(IoTCoreError(errorData));
            });
          } else {
            let data = '';
            res.on('data', chunk => (data += chunk));
            res.on('end', () => {
              const response: protos.google.cloud.iot.v1.IListDevicesResponse =
                {};
              const request: protos.google.cloud.iot.v1.ListDevicesRequest | null =
                null;
              const deviceListResponse = JSON.parse(data);
              const devicesArray: protos.google.cloud.iot.v1.IDevice[] = [];

              for (const index in deviceListResponse.devices) {
                const device: protos.google.cloud.iot.v1.IDevice = {};
                device.id = deviceListResponse.devices[index].id;
                device.name = deviceListResponse.devices[index].name;
                device.numId = deviceListResponse.devices[index].numId;
                device.credentials =
                  deviceListResponse.devices[index].credentials;
                device.lastHeartbeatTime =
                  deviceListResponse.devices[index].lastHeartbeatTime;
                device.lastEventTime =
                  deviceListResponse.devices[index].lastEventTime;
                device.lastStateTime =
                  deviceListResponse.devices[index].lastStateTime;
                device.lastConfigAckTime =
                  deviceListResponse.devices[index].lastConfigAckTime;
                device.lastConfigSendTime =
                  deviceListResponse.devices[index].lastConfigSendTime;
                device.blocked = deviceListResponse.devices[index].blocked;
                device.lastErrorTime =
                  deviceListResponse.devices[index].lastErrorTime;
                device.lastErrorStatus =
                  deviceListResponse.devices[index].lastErrorStatus;
                devicesArray.push(device);
              }
              response.devices = devicesArray;
              resolve([devicesArray, request, response]);
            });
          }
        }
      );
      req.on('error', e => {
        reject(e);
      });
      if (payload) {
        req.write(payload);
      }
      req.end();
    });
  }

  /**
   * Equivalent to `method.name.toCamelCase()`, but returns a NodeJS Stream object.
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The device registry path. Required. For example,
   *   `projects/my-project/locations/us-central1/registries/my-registry`.
   * @param {number[]} request.deviceNumIds
   *   A list of device numeric IDs. If empty, this field is ignored. Maximum
   *   IDs: 10,000.
   * @param {string[]} request.deviceIds
   *   A list of device string IDs. For example, `['device0', 'device12']`.
   *   If empty, this field is ignored. Maximum IDs: 10,000
   * @param {google.protobuf.FieldMask} request.fieldMask
   *   The fields of the `Device` resource to be returned in the response. The
   *   fields `id` and `num_id` are always returned, along with any
   *   other fields specified in snake_case format, for example:
   *   `last_heartbeat_time`.
   * @param {google.cloud.iot.v1.GatewayListOptions} request.gatewayListOptions
   *   Options related to gateways.
   * @param {number} request.pageSize
   *   The maximum number of devices to return in the response. If this value
   *   is zero, the service will select a default size. A call may return fewer
   *   objects than requested. A non-empty `next_page_token` in the response
   *   indicates that more data is available.
   * @param {string} request.pageToken
   *   The value returned by the last `ListDevicesResponse`; indicates
   *   that this is a continuation of a prior `ListDevices` call and
   *   the system should return the next page of data.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Stream}
   *   An object stream which emits an object representing [Device]{@link google.cloud.iot.v1.Device} on 'data' event.
   *   The client library will perform auto-pagination by default: it will call the API as many
   *   times as needed. Note that it can affect your quota.
   *   We recommend using `listDevicesAsync()`
   *   method described below for async iteration which you can stop as needed.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination)
   *   for more details and examples.
   */
  // listDevicesStream(
  //   request?: protos.google.cloud.iot.v1.IListDevicesRequest,
  //   options?: CallOptions
  // ): Transform {
  //   request = request || {};
  //   options = options || {};
  //   options.otherArgs = options.otherArgs || {};
  //   options.otherArgs.headers = options.otherArgs.headers || {};
  //   options.otherArgs.headers['x-goog-request-params'] =
  //     this._gaxModule.routingHeader.fromParams({
  //       parent: request.parent || '',
  //     });
  //   const defaultCallSettings = this._defaults['listDevices'];
  //   const callSettings = defaultCallSettings.merge(options);
  //   this.initialize();
  //   return this.descriptors.page.listDevices.createStream(
  //     this.innerApiCalls.listDevices as GaxCall,
  //     request,
  //     callSettings
  //   );
  // }

  /**
   * Equivalent to `listDevices`, but returns an iterable object.
   *
   * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The device registry path. Required. For example,
   *   `projects/my-project/locations/us-central1/registries/my-registry`.
   * @param {number[]} request.deviceNumIds
   *   A list of device numeric IDs. If empty, this field is ignored. Maximum
   *   IDs: 10,000.
   * @param {string[]} request.deviceIds
   *   A list of device string IDs. For example, `['device0', 'device12']`.
   *   If empty, this field is ignored. Maximum IDs: 10,000
   * @param {google.protobuf.FieldMask} request.fieldMask
   *   The fields of the `Device` resource to be returned in the response. The
   *   fields `id` and `num_id` are always returned, along with any
   *   other fields specified in snake_case format, for example:
   *   `last_heartbeat_time`.
   * @param {google.cloud.iot.v1.GatewayListOptions} request.gatewayListOptions
   *   Options related to gateways.
   * @param {number} request.pageSize
   *   The maximum number of devices to return in the response. If this value
   *   is zero, the service will select a default size. A call may return fewer
   *   objects than requested. A non-empty `next_page_token` in the response
   *   indicates that more data is available.
   * @param {string} request.pageToken
   *   The value returned by the last `ListDevicesResponse`; indicates
   *   that this is a continuation of a prior `ListDevices` call and
   *   the system should return the next page of data.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Object}
   *   An iterable Object that allows [async iteration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).
   *   When you iterate the returned iterable, each element will be an object representing
   *   [Device]{@link google.cloud.iot.v1.Device}. The API will be called under the hood as needed, once per the page,
   *   so you can stop the iteration when you don't need more results.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination)
   *   for more details and examples.
   * @example <caption>include:samples/generated/v1/device_manager.list_devices.js</caption>
   * region_tag:cloudiot_v1_generated_DeviceManager_ListDevices_async
   */
  // listDevicesAsync(
  //   request?: protos.google.cloud.iot.v1.IListDevicesRequest,
  //   options?: CallOptions
  // ): AsyncIterable<protos.google.cloud.iot.v1.IDevice> {
  //   request = request || {};
  //   options = options || {};
  //   options.otherArgs = options.otherArgs || {};
  //   options.otherArgs.headers = options.otherArgs.headers || {};
  //   options.otherArgs.headers['x-goog-request-params'] =
  //     this._gaxModule.routingHeader.fromParams({
  //       parent: request.parent || '',
  //     });
  //   const defaultCallSettings = this._defaults['listDevices'];
  //   const callSettings = defaultCallSettings.merge(options);
  //   this.initialize();
  //   return this.descriptors.page.listDevices.asyncIterate(
  //     this.innerApiCalls['listDevices'] as GaxCall,
  //     request as {},
  //     callSettings
  //   ) as AsyncIterable<protos.google.cloud.iot.v1.IDevice>;
  // }
  // --------------------
  // -- Path templates --
  // --------------------

  /**
   * Return a fully-qualified device resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} registry
   * @param {string} device
   * @returns {string} Resource name string.
   */
  devicePath(
    project: string,
    location: string,
    registry: string,
    device: string
  ) {
    return (
      'projects/' +
      project +
      '/locations/' +
      location +
      '/registries/' +
      registry +
      '/devices/' +
      device
    );
  }

  /**
   * Parse the project from Device resource.
   *
   * @param {string} deviceName
   *   A fully-qualified path representing Device resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromDeviceName(deviceName: string) {
    //return this.pathTemplates.devicePathTemplate.match(deviceName).project;
  }

  /**
   * Parse the location from Device resource.
   *
   * @param {string} deviceName
   *   A fully-qualified path representing Device resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromDeviceName(deviceName: string) {
    //return this.pathTemplates.devicePathTemplate.match(deviceName).location;
  }

  /**
   * Parse the registry from Device resource.
   *
   * @param {string} deviceName
   *   A fully-qualified path representing Device resource.
   * @returns {string} A string representing the registry.
   */
  matchRegistryFromDeviceName(deviceName: string) {
    //return this.pathTemplates.devicePathTemplate.match(deviceName).registry;
  }

  /**
   * Parse the device from Device resource.
   *
   * @param {string} deviceName
   *   A fully-qualified path representing Device resource.
   * @returns {string} A string representing the device.
   */
  matchDeviceFromDeviceName(deviceName: string) {
    //return this.pathTemplates.devicePathTemplate.match(deviceName).device;
  }

  /**
   * Return a fully-qualified location resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @returns {string} Resource name string.
   */
  locationPath(project: string, location: string) {
    return 'projects/' + project + '/locations/' + location;
  }

  /**
   * Parse the project from Location resource.
   *
   * @param {string} locationName
   *   A fully-qualified path representing Location resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromLocationName(locationName: string) {
    //return this.pathTemplates.locationPathTemplate.match(locationName).project;
  }

  /**
   * Parse the location from Location resource.
   *
   * @param {string} locationName
   *   A fully-qualified path representing Location resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromLocationName(locationName: string) {
    //return this.pathTemplates.locationPathTemplate.match(locationName).location;
  }

  /**
   * Return a fully-qualified registry resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} registry
   * @returns {string} Resource name string.
   */
  registryPath(project: string, location: string, registry: string) {
    return (
      'projects/' +
      project +
      '/locations/' +
      location +
      '/registries/' +
      registry
    );
  }

  /**
   * Parse the project from Registry resource.
   *
   * @param {string} registryName
   *   A fully-qualified path representing Registry resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromRegistryName(registryName: string) {
    //return this.pathTemplates.registryPathTemplate.match(registryName).project;
  }

  /**
   * Parse the location from Registry resource.
   *
   * @param {string} registryName
   *   A fully-qualified path representing Registry resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromRegistryName(registryName: string) {
    //return this.pathTemplates.registryPathTemplate.match(registryName).location;
  }

  /**
   * Parse the registry from Registry resource.
   *
   * @param {string} registryName
   *   A fully-qualified path representing Registry resource.
   * @returns {string} A string representing the registry.
   */
  matchRegistryFromRegistryName(registryName: string) {
    //return this.pathTemplates.registryPathTemplate.match(registryName).registry;
  }

  getRegistryFromRegistryPath(registryPath: string | null | undefined) {
    if (registryPath === null || typeof registryPath === 'undefined') {
      throw 'registryPath is empty';
    }
    return registryPath.substring(
      registryPath.indexOf('/registries/') + 12,
      registryPath.length
    );
  }

  getRegionFromRegistryPath(registryPath: string | null | undefined) {
    if (registryPath === null || typeof registryPath === 'undefined') {
      throw 'registryPath is empty';
    }
    return registryPath.substring(
      registryPath.indexOf('/locations/') + 11,
      registryPath.lastIndexOf('/registries')
    );
  }

  getRegistryFromDevicePath(devicePath: string | null | undefined) {
    if (devicePath === null || typeof devicePath === 'undefined') {
      throw 'devicePath is empty';
    }
    return devicePath.substring(
      devicePath.indexOf('/registries/') + 12,
      devicePath.lastIndexOf('/devices')
    );
  }

  getRegionFromDevicePath(devicePath: string | null | undefined) {
    if (devicePath === null || typeof devicePath === 'undefined') {
      throw 'devicePath is empty';
    }
    return devicePath.substring(
      devicePath.indexOf('/locations/') + 11,
      devicePath.lastIndexOf('/registries')
    );
  }

  getDeviceNameFromDevicePath(devicePath: string | null | undefined) {
    if (devicePath === null || typeof devicePath === 'undefined') {
      throw 'devicePath is empty';
    }
    return devicePath.substring(
      devicePath.indexOf('/devices/') + 9,
      devicePath.length
    );
  }

  /**
   * Terminate the gRPC channel and close the client.
   *
   * The client will no longer be usable and all future behavior is undefined.
   * @returns {Promise} A promise that resolves when the client is closed.
   */
  close(): Promise<void> {
    // if (this.deviceManagerStub && !this._terminated) {
    //   return this.deviceManagerStub.then(stub => {
    //     this._terminated = true;
    //     stub.close();
    //   });
    // }
    return Promise.resolve();
  }
}
